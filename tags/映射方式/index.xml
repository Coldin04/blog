<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>映射方式 on Coldin04's Blog</title><link>https://blog.cold04.com/tags/%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/</link><description>Recent content in 映射方式 on Coldin04's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 27 Dec 2025 10:00:00 +0800</lastBuildDate><atom:link href="https://blog.cold04.com/tags/%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>Cache 三种映射方式（直接/全相联/组相联）</title><link>https://blog.cold04.com/p/cache_mapping/</link><pubDate>Sat, 27 Dec 2025 10:00:00 +0800</pubDate><guid>https://blog.cold04.com/p/cache_mapping/</guid><description>&lt;h2 id="基础知识先把底层逻辑讲明白"&gt;基础知识（先把底层逻辑讲明白）
&lt;/h2&gt;&lt;h3 id="一从块开始cache-是什么为什么要映射"&gt;一、从“块”开始：Cache 是什么？为什么要映射？
&lt;/h3&gt;&lt;p&gt;如果你还不知道 Cache 是啥，可以把它理解成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPU 旁边的一小块“超快内存”&lt;/strong&gt;（容量小但速度快）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主存（内存）很大但更慢&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU 运行时会频繁读/写内存。为了避免每次都去“慢的主存”取数据，硬件会把&lt;strong&gt;最近用过、很可能马上还会用到&lt;/strong&gt;的数据，先放进 Cache。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id="为什么-cache-不是按一个字节一个字搬运而是按块block搬运"&gt;为什么 Cache 不是“按一个字节/一个字”搬运，而是“按块（Block）”搬运？
&lt;/h4&gt;&lt;p&gt;因为程序往往有 &lt;strong&gt;局部性（Locality）&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* **时间局部性**：刚用过的数据，可能马上还会用。
* **空间局部性**：访问了地址 A，往往很快也会访问 A 附近的地址。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以 Cache 和主存交换数据时，通常一次把&lt;strong&gt;一整段连续地址&lt;/strong&gt;搬上来，这段连续地址就叫一个 &lt;strong&gt;块（Block）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;举个最直观的例子：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块大小 = 16B&lt;/li&gt;
&lt;li&gt;你读取地址 &lt;code&gt;0x1000&lt;/code&gt; 的 1 个字节&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;硬件往往会把 &lt;code&gt;0x1000 ~ 0x100F&lt;/code&gt; 这 16B &lt;strong&gt;整块&lt;/strong&gt;放进 Cache。
这样你接下来再访问 &lt;code&gt;0x1001&lt;/code&gt;、&lt;code&gt;0x1002&lt;/code&gt;……就很可能直接命中（hit）。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id="映射mapping到底在干嘛"&gt;“映射（Mapping）”到底在干嘛？
&lt;/h4&gt;&lt;p&gt;关键矛盾只有一句：&lt;strong&gt;Cache 容量远小于主存&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;主存里有海量的块，但 Cache 里只有有限的“位置”能放块（这些位置叫 &lt;strong&gt;行 Line&lt;/strong&gt;）。于是必须规定：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“主存的某个块，进 Cache 时允许放到哪些行（或哪些组 Set）里？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个规定就是 &lt;strong&gt;映射方式&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不同映射方式的区别，就体现在：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; - 允许放的位置越多：越不容易互相顶掉（冲突少），但查找/硬件更复杂。
- 允许放的位置越少：查找更快/硬件更简单，但更容易冲突（两个热块老挤一个位置）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这页只讲一件事：&lt;strong&gt;一段内存地址（或内存块）到底怎么“放进”Cache&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id="二一次访问到底发生什么hitmiss-机制"&gt;二、一次访问到底发生什么：Hit/Miss 机制
&lt;/h3&gt;&lt;p&gt;很多同学卡住不是因为公式，而是因为不知道“算出来的 Tag/Index 到底拿去干嘛”。下面给你一个&lt;strong&gt;能直接套题&lt;/strong&gt;的流程。&lt;/p&gt;
&lt;h4 id="cache-一行line里通常有什么"&gt;Cache 一行（Line）里通常有什么
&lt;/h4&gt;&lt;p&gt;把一行想成一个小盒子，里面至少有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Valid 位&lt;/strong&gt;：这行里有没有装过有效数据（没装过就一定 miss）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tag&lt;/strong&gt;：这行当前装的是“主存的哪一个块”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Data（数据块）&lt;/strong&gt;：真正的块内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能还会有（看题目/课程深度，知道即可）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dirty 位&lt;/strong&gt;：写回法（write-back）时用，表示这行数据是否被改过。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换信息&lt;/strong&gt;：比如 LRU 需要的“最近使用情况”。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="一次读写访问的标准流程最重要"&gt;一次读/写访问的标准流程（最重要）
&lt;/h4&gt;&lt;p&gt;不管直接映射/全相联/组相联，流程本质都一样，只是“要检查的行数”不同：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;算块地址 BlockAddr&lt;/strong&gt;：先把地址按块大小折算成“这是第几个块”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;根据映射方式定位候选位置&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接映射：候选 = &lt;strong&gt;1 行&lt;/strong&gt;（算出 LineIndex）。&lt;/li&gt;
&lt;li&gt;组相联：候选 = &lt;strong&gt;1 组内的 k 行&lt;/strong&gt;（算出 SetIndex）。&lt;/li&gt;
&lt;li&gt;全相联：候选 = &lt;strong&gt;全部行&lt;/strong&gt;（没有 Index）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命中判定（Valid + Tag 比较）&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果某个候选行 &lt;code&gt;Valid=1&lt;/code&gt; 且 &lt;code&gt;Tag&lt;/code&gt; 匹配：&lt;strong&gt;Hit&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;否则：&lt;strong&gt;Miss&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hit 之后怎么取数据&lt;/strong&gt;：用 &lt;code&gt;Offset&lt;/code&gt; 在这行的 Data 里取到块内对应的字节/字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Miss 之后会发生什么&lt;/strong&gt;（装入/替换）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从主存把“目标块”取到 Cache。&lt;/li&gt;
&lt;li&gt;若候选位置有空行：直接放进去。&lt;/li&gt;
&lt;li&gt;若没有空行：按替换策略（LRU/FIFO/随机）选一个受害者（victim）顶掉。&lt;/li&gt;
&lt;li&gt;若采用写回法且 victim 的 &lt;code&gt;Dirty=1&lt;/code&gt;：先把 victim 写回主存，再覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="一张从地址到命中缺失的流程图ascii-版"&gt;一张“从地址到命中/缺失”的流程图（ASCII 版）
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;CPU 发起一次访存（给你一个地址 Addr）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 按块大小切：BlockAddr = floor(Addr / BlockSize)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 按映射方式定位候选位置（行/组）：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 直接映射：LineIndex = BlockAddr mod NumLines
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 组相联： SetIndex = BlockAddr mod NumSets（组内 k 路都要查）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; - 全相联： 候选 = 全部行
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 在候选行里做命中判定：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 若存在某行：Valid=1 且 Tag 匹配 ---&amp;gt; HIT
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 否则 ---&amp;gt; MISS
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | 选空行或按替换策略挑 victim
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | (若 write-back 且 victim Dirty=1 则先写回)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | 从主存取目标块，装入 Cache
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; v v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 用 Offset 取块内数据/完成读写 重新访问（这次通常会 hit）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id="写策略题目不考细节也能看懂"&gt;写策略（题目不考细节也能看懂）
&lt;/h4&gt;&lt;p&gt;写操作常见两对策略（题目若没说，通常只考映射/命中率，写策略可忽略）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Write-through（写直达）&lt;/strong&gt;：写 Cache 同时写主存（简单但慢）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write-back（写回）&lt;/strong&gt;：先只写 Cache，换出时再写回（快但要 Dirty 位）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write-allocate（写分配）&lt;/strong&gt;：写 miss 也把块先装入 Cache 再写（常见）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;No-write-allocate&lt;/strong&gt;：写 miss 不装入 Cache，直接写主存（某些场景用）。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="三术语对齐块block-行line-组set"&gt;三、术语对齐：块（Block）/ 行（Line）/ 组（Set）
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;块（Block）&lt;/strong&gt;：Cache 和主存交换数据的最小单位。题目常给“块大小 = 4 字 / 16B”等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行（Line）&lt;/strong&gt;：Cache 里存放一个块的位置。有时也叫“Cache 块”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组（Set）&lt;/strong&gt;：组相联里的一组“行”。例如 2 路组相联 = 每组 2 行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你只要记住：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;直接映射&lt;/strong&gt;：每个主存块只能去 Cache 的“唯一一行”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全相联&lt;/strong&gt;：每个主存块可以去 Cache 的“任意一行”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组相联&lt;/strong&gt;：每个主存块只能去“唯一一组”，但在组里可以去“任意一行”。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="四三种映射方式总览先建立直觉"&gt;四、三种映射方式总览（先建立直觉）
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;方式&lt;/th&gt;
&lt;th&gt;主存块能放到哪里&lt;/th&gt;
&lt;th style="text-align: right"&gt;查找速度&lt;/th&gt;
&lt;th style="text-align: right"&gt;硬件成本&lt;/th&gt;
&lt;th&gt;常见缺失类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;直接映射 (Direct Mapped)&lt;/td&gt;
&lt;td&gt;固定 1 行&lt;/td&gt;
&lt;td style="text-align: right"&gt;最快&lt;/td&gt;
&lt;td style="text-align: right"&gt;最低&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;冲突缺失&lt;/strong&gt;明显&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;全相联 (Fully Associative)&lt;/td&gt;
&lt;td&gt;任意行&lt;/td&gt;
&lt;td style="text-align: right"&gt;最慢&lt;/td&gt;
&lt;td style="text-align: right"&gt;最高&lt;/td&gt;
&lt;td&gt;基本无冲突缺失&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;组相联 (Set Associative)&lt;/td&gt;
&lt;td&gt;固定 1 组 + 组内任意行&lt;/td&gt;
&lt;td style="text-align: right"&gt;居中&lt;/td&gt;
&lt;td style="text-align: right"&gt;居中&lt;/td&gt;
&lt;td&gt;冲突缺失缓解&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;缺失（Miss）通常分三类（考试高频）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;强制缺失&lt;/strong&gt;（Compulsory/Cold Miss）：第一次访问某块必 miss。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容量缺失&lt;/strong&gt;（Capacity Miss）：Cache 总容量不够，装不下要用的块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;冲突缺失&lt;/strong&gt;（Conflict Miss）：容量够，但“映射规则”把多个块挤到同一行/同一组。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="五地址怎么切tag--index--offset"&gt;五、地址怎么切：Tag / Index / Offset
&lt;/h3&gt;&lt;p&gt;题目常写：&lt;/p&gt;
$$ \text{Address} = \text{Tag} \parallel \text{Index} \parallel \text{Offset} $$&lt;p&gt;含义（按字节寻址的经典默认）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Offset（块内偏移）&lt;/strong&gt;：你要这个块里的第几个字节/字。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Index（索引）&lt;/strong&gt;：去 Cache 的哪一行（直接映射）/哪一组（组相联）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Tag（标记）&lt;/strong&gt;：用来确认“这一行/这一组里装的到底是哪一个主存块”。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id="三种映射方式核心"&gt;三种映射方式（核心）
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;块地址（Block Address）：&lt;/p&gt;
$$ \text{BlockAddr} = \left\lfloor \frac{\text{MemAddr}}{\text{BlockSize}} \right\rfloor $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接映射：&lt;/p&gt;
$$ \text{LineIndex} = \text{BlockAddr} \bmod \text{NumLines} $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$k$ 路组相联（$k$-way）：&lt;/p&gt;
$$ \text{SetIndex} = \text{BlockAddr} \bmod \text{NumSets},\quad \text{NumSets}=\frac{\text{NumLines}}{k} $$&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;小提示：如果题目给的访问序列看起来像 &lt;code&gt;16,17,18,19 ...&lt;/code&gt; 这种“连续加 1”，很可能给的是&lt;strong&gt;字地址&lt;/strong&gt;或&lt;strong&gt;字节地址&lt;/strong&gt;；你要先用块大小把它们折算成块地址（上面的 BlockAddr）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id="一直接映射direct-mapped"&gt;一、直接映射（Direct Mapped）
&lt;/h3&gt;&lt;h4 id="规则一句话版"&gt;规则（一句话版）
&lt;/h4&gt;&lt;p&gt;每个主存块只能映射到 Cache 的&lt;strong&gt;唯一一行&lt;/strong&gt;：&lt;/p&gt;
$$ \text{LineIndex} = \text{BlockAddr} \bmod \text{NumLines} $$&lt;h4 id="做题时你在做什么"&gt;做题时你在做什么
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先算这个访问属于哪个 &lt;strong&gt;BlockAddr&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再用取模算出它去 &lt;strong&gt;哪一行&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去那一行比对 &lt;strong&gt;Tag&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tag 相同：&lt;strong&gt;命中（Hit）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Tag 不同或空：&lt;strong&gt;缺失（Miss）&lt;/strong&gt;，把新块塞进来（旧的被直接踢掉）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id="直观图"&gt;直观图
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://blog.cold04.com/p/cache_mapping/Direct_Mapped_Cache.svg"
loading="lazy"
alt="Direct Mapped Cache"
&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="二全相联fully-associative"&gt;二、全相联（Fully Associative）
&lt;/h3&gt;&lt;h4 id="规则一句话版-1"&gt;规则（一句话版）
&lt;/h4&gt;&lt;p&gt;主存块可以进 Cache 的&lt;strong&gt;任意一行&lt;/strong&gt;，所以 &lt;strong&gt;没有 Index&lt;/strong&gt;（或 Index 长度为 0）。&lt;/p&gt;
&lt;h4 id="做题时你需要注意什么"&gt;做题时你需要注意什么
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;命中判定：要在“所有行”里找 Tag（硬件用并行比较，题目里就理解为“全表查”）。&lt;/li&gt;
&lt;li&gt;缺失时：必须有 &lt;strong&gt;替换策略&lt;/strong&gt;（LRU/FIFO/随机）。题目不说通常默认随机或 LRU（看老师口径）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="直观图-1"&gt;直观图
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://blog.cold04.com/p/cache_mapping/Fully_Associative_Cache.svg"
loading="lazy"
alt="Fully Associative Cache"
&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id="三组相联set-associative"&gt;三、组相联（Set Associative）
&lt;/h3&gt;&lt;h4 id="规则一句话版-2"&gt;规则（一句话版）
&lt;/h4&gt;&lt;p&gt;主存块只能去&lt;strong&gt;唯一一组&lt;/strong&gt;，但可以放到组内&lt;strong&gt;任意一路（way）&lt;/strong&gt;：&lt;/p&gt;
$$ \text{SetIndex} = \text{BlockAddr} \bmod \text{NumSets} $$&lt;h4 id="2-路组相联你脑中应该出现的画面"&gt;2 路组相联：你脑中应该出现的画面
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Cache 被分成很多组（Set）。&lt;/li&gt;
&lt;li&gt;每组里有 2 行（2 way）。&lt;/li&gt;
&lt;li&gt;来了一个块：先用取模找到组号；再在这组里两行都比 Tag。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="直观图-2"&gt;直观图
&lt;/h4&gt;&lt;p&gt;&lt;img src="https://blog.cold04.com/p/cache_mapping/Set_Associative_Cache.svg"
loading="lazy"
alt="Set Associative Cache"
&gt;
&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="题目与练习把分数拿到手"&gt;题目与练习（把分数拿到手）
&lt;/h2&gt;&lt;h3 id="一一个极小例子把三种方式算通"&gt;一、一个极小例子把三种方式“算通”
&lt;/h3&gt;&lt;p&gt;假设（为了演示简单）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Cache 一共 4 行&lt;/li&gt;
&lt;li&gt;块大小 = 1（忽略 Offset）&lt;/li&gt;
&lt;li&gt;访问的块序列：&lt;code&gt;0, 4, 0, 4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="直接映射4-行"&gt;直接映射（4 行）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LineIndex = BlockAddr mod 4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 和 4 都映射到行 0&lt;/li&gt;
&lt;li&gt;结果：&lt;code&gt;0&lt;/code&gt; miss，&lt;code&gt;4&lt;/code&gt; miss（顶掉 0），&lt;code&gt;0&lt;/code&gt; miss（顶掉 4），&lt;code&gt;4&lt;/code&gt; miss&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全是 miss&lt;/strong&gt;：典型的冲突缺失&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="全相联4-行"&gt;全相联（4 行）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;0、4 都能进任意行&lt;/li&gt;
&lt;li&gt;结果：&lt;code&gt;0&lt;/code&gt; miss，&lt;code&gt;4&lt;/code&gt; miss，&lt;code&gt;0&lt;/code&gt; hit，&lt;code&gt;4&lt;/code&gt; hit&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-路组相联4-行--2-组--2-路"&gt;2 路组相联（4 行 = 2 组 × 2 路）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NumSets=2&lt;/code&gt;，&lt;code&gt;SetIndex=BlockAddr mod 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;0 和 4 都落到组 0，但组 0 有 2 路&lt;/li&gt;
&lt;li&gt;结果：&lt;code&gt;0&lt;/code&gt; miss，&lt;code&gt;4&lt;/code&gt; miss（组0 还装得下），&lt;code&gt;0&lt;/code&gt; hit，&lt;code&gt;4&lt;/code&gt; hit&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="二题目分析"&gt;二、题目分析
&lt;/h3&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Cache：&lt;strong&gt;2 路组相联&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Cache 总行数：&lt;strong&gt;32 行（块）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;块大小：&lt;strong&gt;4 字（word）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;地址位宽：&lt;strong&gt;16 位&lt;/strong&gt;（本题命中率计算不一定用到位宽）&lt;/li&gt;
&lt;li&gt;访存序列（看起来是“字地址”）：
&lt;code&gt;16 17 18 19 144 145 146 147 252 253 465 466&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4 id="第一步把地址先变成块地址-blockaddr"&gt;第一步：把“地址”先变成“块地址 BlockAddr”
&lt;/h4&gt;&lt;p&gt;块大小是 4 字，所以每 4 个连续字地址属于同一个块：&lt;/p&gt;
$$ \text{BlockAddr} = \left\lfloor \frac{\text{WordAddr}}{4} \right\rfloor $$&lt;p&gt;把序列换成块地址：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;16~19&lt;/code&gt; 都在块 $\lfloor 16/4 \rfloor = 4$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;144~147&lt;/code&gt; 都在块 $\lfloor 144/4 \rfloor = 36$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;252~253&lt;/code&gt; 都在块 $\lfloor 252/4 \rfloor = 63$&lt;/li&gt;
&lt;li&gt;&lt;code&gt;465~466&lt;/code&gt; 都在块 $\lfloor 465/4 \rfloor = 116$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以块序列是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;4,4,4,4, 36,36,36,36, 63,63, 116,116&lt;/code&gt;&lt;/p&gt;
&lt;h4 id="第二步算组号2-路组相联"&gt;第二步：算组号（2 路组相联）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;总行数 32，2 路 $\Rightarrow$ 组数：&lt;/p&gt;
$$ \text{NumSets} = 32/2 = 16 $$&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组号：&lt;/p&gt;
$$ \text{SetIndex} = \text{BlockAddr} \bmod 16 $$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;计算：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块 4：$4\bmod 16=4$（组 4）&lt;/li&gt;
&lt;li&gt;块 36：$36\bmod 16=4$（组 4）&lt;/li&gt;
&lt;li&gt;块 63：$63\bmod 16=15$（组 15）&lt;/li&gt;
&lt;li&gt;块 116：$116\bmod 16=4$（组 4）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：&lt;strong&gt;4、36、116 三个块都挤在同一组（组 4）&lt;/strong&gt;，这就是本题的“冲突热点”。&lt;/p&gt;
&lt;h4 id="第三步按替换策略判-hitmiss假设初始-cache-为空组内-lru"&gt;第三步：按替换策略判 Hit/Miss（假设初始 Cache 为空，组内 LRU）
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;访问块 4：miss（把块 4 装入组 4）&lt;/li&gt;
&lt;li&gt;再访问块 4 三次：hit、hit、hit（同一块内连续访问，体现空间局部性）&lt;/li&gt;
&lt;li&gt;访问块 36：miss（组 4 还有空位，装入）&lt;/li&gt;
&lt;li&gt;再访问块 36 三次：hit、hit、hit&lt;/li&gt;
&lt;li&gt;访问块 63：miss（装入组 15）&lt;/li&gt;
&lt;li&gt;再访问块 63 一次：hit&lt;/li&gt;
&lt;li&gt;访问块 116：miss（组 4 满了，需要替换；LRU 会踢掉“更久没用”的块 4）&lt;/li&gt;
&lt;li&gt;再访问块 116 一次：hit&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;统计：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总访问：12 次&lt;/li&gt;
&lt;li&gt;miss：4 次（第一次见到块 4 / 36 / 63 / 116）&lt;/li&gt;
&lt;li&gt;hit：8 次&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;命中率：&lt;/p&gt;
$$ \text{HitRate} = \frac{8}{12} = \frac{2}{3} \approx 66.7\% $$&lt;h4 id="这题在考你什么"&gt;这题在考你什么
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;块大小带来的空间局部性&lt;/strong&gt;：&lt;code&gt;16~19&lt;/code&gt; 一次装块后后面 3 次都 hit。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组相联缓解冲突&lt;/strong&gt;：虽然 4、36、116 都落同一组，但 2 路能同时容纳其中两个。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;替换策略影响细节&lt;/strong&gt;：如果后续又访问块 4，就会因为刚才被踢掉而 miss。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id="三举一反一一个正例--一个反例"&gt;三、举一反一（一个正例 + 一个反例）
&lt;/h3&gt;&lt;h4 id="正例先算块地址再算组号行号"&gt;正例：先“算块地址”再“算组号/行号”
&lt;/h4&gt;&lt;p&gt;题设：块大小 4 字，访问字地址 &lt;code&gt;145&lt;/code&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;块地址：$\lfloor 145/4 \rfloor = 36$&lt;/li&gt;
&lt;li&gt;2 路组相联，32 行 $\Rightarrow$ 16 组&lt;/li&gt;
&lt;li&gt;组号：$36\bmod 16=4$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;结论：&lt;strong&gt;它一定在组 4（组内哪一路要看替换策略与当前内容）&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id="反例把字地址当成块地址直接取模常见低级错"&gt;反例：把“字地址”当成“块地址”直接取模（常见低级错）
&lt;/h4&gt;&lt;p&gt;错误做法：直接拿 &lt;code&gt;145 mod 16 = 1&lt;/code&gt;，说它在组 1。&lt;/p&gt;
&lt;p&gt;为什么错？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 Cache 映射是按“块”为单位的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;145&lt;/code&gt; 是块内的一个字地址，它属于块 36；映射应该用 36 去取模，而不是用 145。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;</description></item></channel></rss>